{
    "pdb_debug": {
        "prefix": "pdb",
        "body": [
            "import pdb; pdb.set_trace()"
        ],
        "description": "pdbのdebug"
    },
    "int_input": {
        "prefix": "int_input",
        "body": [
            "l = list(map(int, input().split()))"
        ],
        "description": "intを要素として入力をlistで受け取る"
    },
    "combination": {
        "prefix": "combination",
        "body": [
            "from operator import mul",
            "from functools import reduce",
            "def cmb(n, r):",
            "    r = min(n-r, r)",
            "    if r == 0:",
            "        return 1",
            "    elif r < 0:",
            "        return 0",
            "    over = reduce(mul, range(n, n - r, -1))",
            "    under = reduce(mul, range(1, r + 1))",
            "    return over // under"
        ],
        "description": "intを要素として入力をlistで受け取る"
    },
    "is_prime": {
        "prefix": "is_prime",
        "body": [
            "def is_prime(n: int) -> bool:",
            "  for i in range(2, int(math.sqrt(n))+1):",
            "      if n % i == 0:",
            "        return False",
            "  return True"
        ],
        "description": "intを要素として入力をlistで受け取る"
    },
    "derot": {
        "prefix": "derot",
        "body": [
            "def derot_n(s, n) -> str:",
            "    \"\"\"",
            "    アルファベットsをn文字分戻す",
            "    \"\"\"",
            "    answer = ''",
            "    for letter in s:",
            "        answer += chr(ord('Z') - (ord('Z')-ord(letter)+n) % 26)",
            "",
            "    return answer",
            ""
        ],
        "description": ""
    },
    "dxy4": {
        "prefix": "dxy4",
        "body": [
            "dxy = [(0, 1), (0, -1), (1, 0), (-1, 0)]"
        ],
        "description": ""
    },
    "dxy8": {
        "prefix": "dxy4",
        "body": [
            "dxy = [(0, 1), (0, -1), (1, 0), (-1, 0), (1, 1), (1, -1), (-1, 1), (-1, -1)]"
        ],
        "description": ""
    },
    "perm": {
        "prefix": "perm",
        "body": [
            "import math",
            "",
            "def permutation(n, r) -> int:",
            "    \"\"\"",
            "    順列の計算",
            "    \"\"\"",
            "    return math.factorial(n) // math.factorial(n-r)",
            ""
        ],
        "description": ""
    },
    "rot": {
        "prefix": "rot",
        "body": [
            "def rot_n(s, n) -> str:",
            "    \"\"\"",
            "    アルファベットsをn文字分後にずらす",
            "    \"\"\"",
            "    answer = ''",
            "    for letter in s:",
            "        answer += chr(ord('A') + (ord(letter)-ord('A')+n) % 26)",
            "    return answer",
            ""
        ],
        "description": ""
    },
    "kaiten_gyouretu": {
        "prefix": "kaiten_gyouretu",
        "body": [
            "from math import radians, cos, sin",
            "",
            "",
            "def rotation_matrix(x, y, angle):",
            "    # 回転行列",
            "    rad = radians(angle)",
            "    ans = (x * cos(rad) - y * sin(rad), x * sin(rad) + y * cos(rad))",
            "    return ans",
            ""
        ],
        "description": ""
    },
    "intersection_point_kouten": {
        "prefix": "intersection_point_kouten",
        "body": [
            "def check_heikou(a1, b1, c1, a2, b2, c2):",
            "    det = a1 * b2 - a2 * b1",
            "    if det == 0:",
            "      return False",
            "    return True",
            "",
            "def intersection(a1, b1, c1, a2, b2, c2):",
            "    det = a1 * b2 - a2 * b1",
            "    x = (b2 * c1 - b1 * c2) / det",
            "    y = (a1 * c2 - a2 * c1) / det",
            "    y = (a1 * c2 - a2 * c1) / det",
            "    return x, y"
        ],
        "description": "1次方程式の2直線の交点を求める"
    },
    "module_comb_pow": {
        "prefix": "module_comb_pow",
        "body": [
            "class ModuloComb:",
            "  def __init__(self, mod, num_factorial):",
            "      self.mod = mod",
            "      self.factorial = [ None ] * (num_factorial + 1) # factorial[i] = i! % mod",
            "      self.factorial[0] = 1",
            "      for i in range(1, num_factorial + 1):",
            "          self.factorial[i] = self.factorial[i - 1] * i % self.mod",
            "  ",
            "  def comb(self, n, r):",
            "      return self.moddiv(self.factorial[n], self.factorial[r] * self.factorial[n - r] % self.mod)",
            "  ",
            "  def moddiv(self, a, b): # (a / b) % mod",
            "      return (a * self.modpow(b, self.mod - 2)) % self.mod",
            "  ",
            "  def modpow(self, a, b):",
            "      p = a",
            "      answer = 1",
            "      for i in range(30):",
            "          if (b & (1 << i)) != 0:",
            "              answer = (answer * p) % self.mod",
            "          p = (p * p) % self.mod",
            "      return answer"
        ]
    },
    "Vector2D": {
        "prefix": "vector",
        "body": [
            "class Vector2D:",
            "    def __init__(self, x=0, y=0):",
            "        self.x = x",
            "        self.y = y",
            "",
            "    def __str__(self):",
            "        return f\"({self.x}, {self.y})\"",
            "",
            "    def __add__(self, other):",
            "        return Vector2D(self.x + other.x, self.y + other.y)",
            "",
            "    def __sub__(self, other):",
            "        return Vector2D(self.x - other.x, self.y - other.y)",
            "",
            "    def __mul__(self, scalar):",
            "        return Vector2D(self.x * scalar, self.y * scalar)",
            "",
            "    def __truediv__(self, scalar):",
            "        return Vector2D(self.x / scalar, self.y / scalar)",
            "",
            "    # 内積",
            "    def dot(self, other):",
            "        return self.x * other.x + self.y * other.y",
            "",
            "    # 外積",
            "    def cross(self, other):",
            "        return self.x * other.y - self.y * other.x",
            "",
            "    def length(self):",
            "        return math.sqrt(self.x ** 2 + self.y ** 2)",
            "",
            "    def normalize(self):",
            "        length = self.length()",
            "        if length != 0:",
            "            self.x /= length",
            "            self.y /= length",
            "",
            "    def rotated(self, angle):",
            "        rad = math.radians(angle)",
            "        cos = math.cos(rad)",
            "        sin = math.sin(rad)",
            "        x = self.x * cos - self.y * sin",
            "        y = self.x * sin + self.y * cos",
            "        return Vector2D(x, y)"
        ],
        "description": "2次元ベクトルクラス"
    },
    "Matrix power": {
        "prefix": "matrix_power",
        "body": [
            "from copy import deepcopy",
            "",
            "MOD = 10**9 + 7",
            "",
            "# 2×2 行列 A, B の積を返す関数",
            "def multiply(A, B):",
            "    global MOD",
            "    C = [[0, 0], [0, 0]]",
            "    for i in range(2):",
            "        for j in range(2):",
            "            for k in range(2):",
            "                C[i][j] += A[i][k] * B[k][j]",
            "                C[i][j] %= MOD",
            "    return C",
            "",
            "# A の n 乗を返す関数",
            "def power(A, n):",
            "    P = deepcopy(A)",
            "    Q = [[0, 0], [0, 0]]",
            "    flag = False",
            "    for i in range(60):",
            "        if (n & (1 << i)) != 0:",
            "            if flag == False:",
            "                Q = deepcopy(P)",
            "                flag = True",
            "            else:",
            "                Q = deepcopy(multiply(Q, P))",
            "        P = deepcopy(multiply(P, P))",
            "    return Q"
        ],
        "description": "Calculate the power of a 2x2 matrix modulo MOD using bitwise operations"
    },
    "UnionFind": {
        "prefix": "unionfind",
        "body": [
            "class UnionFind:",
            "    def __init__(self, n):",
            "        self.n = n",
            "        self.parent_size = [-1]*n",
            "",
            "    def leader(self, a):",
            "        if self.parent_size[a] < 0:",
            "            return a",
            "        self.parent_size[a] = self.leader(self.parent_size[a])",
            "        return self.parent_size[a]",
            "",
            "    def merge(self, a, b):",
            "        x, y = self.leader(a), self.leader(b)",
            "        if x == y:",
            "            return",
            "        if abs(self.parent_size[x]) < abs(self.parent_size[y]):",
            "            x, y = y, x",
            "        self.parent_size[x] += self.parent_size[y]",
            "        self.parent_size[y] = x",
            "",
            "    def same(self, a, b):",
            "        return self.leader(a) == self.leader(b)",
            "",
            "    def size(self, a):",
            "        return abs(self.parent_size[self.leader(a)])",
            "",
            "    def groups(self):",
            "        result = [[] for _ in range(self.n)]",
            "        for i in range(self.n):",
            "            result[self.leader(i)].append(i)",
            "        return [r for r in result if r != []]"
        ],
        "description": "UnionFind class"
    },
    "Prime Factorization": {
        "prefix": "prime_fact",
        "body": [
            "def factorization(n):",
            "    arr = []",
            "    temp = n",
            "    for i in range(2, int(-(-n**0.5//1))+1):",
            "        if temp % i == 0:",
            "            cnt = 0",
            "            while temp % i == 0:",
            "                cnt += 1",
            "                temp //= i",
            "            arr.append([i, cnt])",
            "",
            "    if temp != 1:",
            "        arr.append([temp, 1])",
            "",
            "    if arr == []:",
            "        arr.append([n, 1])",
            "",
            "    return arr"
        ],
        "description": "Prime factorization function(素因数分解)"
    },
    "nCr_mod": {
        "prefix": "nCr_mod",
        "body": [
            "def nCr_mod(n: int, r: int, mod: int) -> int:",
            "    # 分子",
            "    numerator = 1",
            "    for i in range(n-r+1, n+1):",
            "        numerator = numerator * i % mod",
            "    # 分母",
            "    demoninator = 1",
            "    for i in range(1, r+1):",
            "        demoninator = demoninator * i % mod",
            "    # 分子*分母の逆元",
            "    return numerator * pow(demoninator, mod-2, mod) % mod"
        ],
        "description": "素早くコンビネーションをmodで割った余りを求める"
    },
    "Segment Tree": {
        "prefix": "Segtree",
        "body": [
            "# セグメントツリー",
            "# 演算",
            "",
            "def segfunc(x, y):",
            "    return x+y",
            "",
            "class SegTree:",
            "    # 初期化(元のリスト、単位元、演算)",
            "    def __init__(self, x_list, init, segfunc):",
            "        # 単位元",
            "        self.init = init",
            "        # 演算",
            "        self.segfunc = segfunc",
            "        # 高さ=もとの数列の長さのビット長+1",
            "        self.Height = len(x_list).bit_length()+1",
            "        # 木",
            "        self.Tree = [init]*(2**self.Height)",
            "        # Tree最下段一番左のインデックス番号",
            "        self.num = 2**(self.Height-1)",
            "        # 最下段に要素をセット",
            "        for i in range(len(x_list)):",
            "            self.Tree[2**(self.Height-1)+i] = x_list[i]",
            "        # 上に向かって構築",
            "        for i in range(2**(self.Height-1)-1, 0, -1):",
            "            self.Tree[i] = segfunc(self.Tree[2*i], self.Tree[2*i+1])",
            "",
            "    # 参照",
            "    def select(self, k):",
            "        return self.Tree[k+self.num]",
            "",
            "    # 更新(k番目(0インデックス),値)",
            "    def update(self, k, x):",
            "        # 最下段のインデックス番号に合わせる",
            "        i = k+self.num",
            "        # 最下段の要素を更新",
            "        self.Tree[i] = x",
            "        # 上に向かって更新",
            "        while i > 1:",
            "            # iが偶数の時",
            "            if i % 2 == 0:",
            "                self.Tree[i//2] = self.segfunc(self.Tree[i], self.Tree[i+1])",
            "            # iが奇数の時",
            "            else:",
            "                self.Tree[i//2] = self.segfunc(self.Tree[i-1], self.Tree[i])",
            "            i //= 2",
            "    ",
            "    # 区間の処理",
            "    def query(self, l, r):",
            "        # 下から処理",
            "        # 計算結果　初期値は単位元",
            "        result = self.init",
            "        # 左端　最下段のインデックスに合わせる",
            "        l += self.num",
            "        # 右端　最下段のインデックスに合わせる　後の処理を楽にするため+1しておく",
            "        r += self.num+1",
            "        ",
            "        while l < r:",
            "            # lが奇数だったら",
            "            if l % 2 == 1:",
            "                # 値を使う",
            "                result = self.segfunc(result, self.Tree[l])",
            "                # 一個右に移動",
            "                l += 1",
            "            # rが奇数だったら",
            "            if r % 2 == 1:",
            "                # 値を使う",
            "                result = self.segfunc(result, self.Tree[r-1])",
            "            l //= 2",
            "            r //= 2",
            "        # 結果を返す",
            "        return result"
        ],
        "description": "Define a segment tree class and its operations"
    },
    "Binary Search megur": {
        "prefix": "BinarySearch",
        "body": [
            "class BinarySearch:",
            "    def __init__(self, args):",
            "        \"\"\"",
            "        argsに元になる配列とか条件の判定に使うものを入れるとよし",
            "        何個でも可能",
            "        \"\"\"",
            "        self.args = sorted(args)",
            "",
            "    def cond_helper(self, x):",
            "        \"\"\"",
            "        is_ok単独では条件判定が長くなるなら適当にヘルパー関数を作るとよし",
            "        \"\"\"",
            "        pass",
            "",
            "    def is_ok(self, x):",
            "        \"\"\"",
            "        ヘルパー関数とか使ってよしなにやるとよし",
            "        \"\"\"",
            "        pass",
            "",
            "    def meguru_bisect(self, ng, ok):",
            "        '''",
            "        初期値のng,okを受け取り,is_okを満たす最小(最大)のokを返す",
            "        まずis_okを定義すべし",
            "        ng ok は  とり得る最小の値-1 とり得る最大の値+1",
            "        最大最小が逆の場合はよしなにひっくり返す",
            "        '''",
            "        while (abs(ok - ng) > 1):",
            "            mid = (ok + ng) // 2",
            "            if self.is_ok(mid):",
            "                ok = mid",
            "            else:",
            "                ng = mid",
            "        return ok",
            ""
        ],
        "description": "Python Binary Search Class"
    },
    "BinaryTree for Competitive Programming": {
        "prefix": "BinaryTree",
        "body": [
            "class BinaryTree:",
            "    def __init__(self, max_query=2*10**5, bitlen=30):",
            "        n = max_query * bitlen",
            "        self.nodes = [-1] * (2 * n)",
            "        self.cnt = [0] * n",
            "        self.id = 0",
            "        self.bitlen = bitlen",
            "    def size(self):",
            "        return self.cnt[0]",
            "    def count(self, x):",
            "        pt = 0",
            "        for i in range(self.bitlen-1, -1, -1):",
            "            y = x >> i & 1",
            "            if self.nodes[2*pt+y] == -1:",
            "                return 0",
            "            pt = self.nodes[2*pt+y]",
            "        return self.cnt[pt]",
            "    def insert(self, x):",
            "        pt = 0",
            "        for i in range(self.bitlen-1, -1, -1):",
            "            y = x >> i & 1",
            "            if self.nodes[2*pt+y] == -1:",
            "                self.id += 1",
            "                self.nodes[2*pt+y] = self.id",
            "            self.cnt[pt] += 1",
            "            pt = self.nodes[2*pt+y]",
            "        self.cnt[pt] += 1",
            "    def erase(self, x):",
            "        if self.count(x) == 0:",
            "            return",
            "        pt = 0",
            "        for i in range(self.bitlen-1, -1, -1):",
            "            y = x >> i & 1",
            "            self.cnt[pt] -= 1",
            "            pt = self.nodes[2*pt+y]",
            "        self.cnt[pt] -= 1",
            "    def kth_elm(self, x):",
            "        assert 1 <= x <= self.size()",
            "        pt, ans = 0, 0",
            "        for i in range(self.bitlen-1, -1, -1):",
            "            ans <<= 1",
            "            if self.nodes[2*pt] != -1 and self.cnt[self.nodes[2*pt]] > 0:",
            "                if self.cnt[self.nodes[2*pt]] >= x:",
            "                    pt = self.nodes[2*pt]",
            "                else:",
            "                    x -= self.cnt[self.nodes[2*pt]]",
            "                    pt = self.nodes[2*pt+1]",
            "                    ans += 1",
            "            else:",
            "                pt = self.nodes[2*pt+1]",
            "                ans += 1",
            "        return ans",
            "    def lower_bound(self, x):",
            "        pt, ans = 0, 1",
            "        for i in range(self.bitlen-1, -1, -1):",
            "            if pt == -1:",
            "                break",
            "            if x >> i & 1 and self.nodes[2*pt] != -1:",
            "                ans += self.cnt[self.nodes[2*pt]]",
            "            pt = self.nodes[2*pt+(x >> i & 1)]",
            "        return ans"
        ],
        "description": "BinaryTree for Competitive Programming"
    },
    "sortedset": {
        "prefix": "sortedset",
        "body": [
            "import math",
            "from bisect import bisect_left, bisect_right",
            "from typing import Generic, Iterable, Iterator, List, Tuple, TypeVar, Optional",
            "T = TypeVar('T')",
            "",
            "class SortedSet(Generic[T]):",
            "    BUCKET_RATIO = 16",
            "    SPLIT_RATIO = 24",
            "    ",
            "    def __init__(self, a: Iterable[T] = []) -> None:",
            "        \"\"\"Make a new SortedSet from iterable. / O(N) if sorted and unique / O(N log N)\"\"\"",
            "        a = list(a)",
            "        n = len(a)",
            "        if any(a[i] > a[i + 1] for i in range(n - 1)):",
            "            a.sort()",
            "        if any(a[i] >= a[i + 1] for i in range(n - 1)):",
            "            a, b = [], a",
            "            for x in b:",
            "                if not a or a[-1] != x:",
            "                    a.append(x)",
            "        n = self.size = len(a)",
            "        num_bucket = int(math.ceil(math.sqrt(n / self.BUCKET_RATIO)))",
            "        self.a = [a[n * i // num_bucket : n * (i + 1) // num_bucket] for i in range(num_bucket)]",
            "",
            "    def __iter__(self) -> Iterator[T]:",
            "        for i in self.a:",
            "            for j in i: yield j",
            "",
            "    def __reversed__(self) -> Iterator[T]:",
            "        for i in reversed(self.a):",
            "            for j in reversed(i): yield j",
            "    ",
            "    def __eq__(self, other) -> bool:",
            "        return list(self) == list(other)",
            "    ",
            "    def __len__(self) -> int:",
            "        return self.size",
            "    ",
            "    def __repr__(self) -> str:",
            "        return \"SortedSet\" + str(self.a)",
            "    ",
            "    def __str__(self) -> str:",
            "        s = str(list(self))",
            "        return \"{\" + s[1 : len(s) - 1] + \"}\"",
            "",
            "    def _position(self, x: T) -> Tuple[List[T], int, int]:",
            "        \"\"\"return the bucket, index of the bucket and position in which x should be. self must not be empty.\"\"\"",
            "        for i, a in enumerate(self.a):",
            "            if x <= a[-1]: break",
            "        return (a, i, bisect_left(a, x))",
            "",
            "    def __contains__(self, x: T) -> bool:",
            "        if self.size == 0: return False",
            "        a, _, i = self._position(x)",
            "        return i != len(a) and a[i] == x",
            "",
            "    def add(self, x: T) -> bool:",
            "        \"\"\"Add an element and return True if added. / O(√N)\"\"\"",
            "        if self.size == 0:",
            "            self.a = [[x]]",
            "            self.size = 1",
            "            return True",
            "        a, b, i = self._position(x)",
            "        if i != len(a) and a[i] == x: return False",
            "        a.insert(i, x)",
            "        self.size += 1",
            "        if len(a) > len(self.a) * self.SPLIT_RATIO:",
            "            mid = len(a) >> 1",
            "            self.a[b:b+1] = [a[:mid], a[mid:]]",
            "        return True",
            "    ",
            "    def _pop(self, a: List[T], b: int, i: int) -> T:",
            "        ans = a.pop(i)",
            "        self.size -= 1",
            "        if not a: del self.a[b]",
            "        return ans",
            "",
            "    def discard(self, x: T) -> bool:",
            "        \"\"\"Remove an element and return True if removed. / O(√N)\"\"\"",
            "        if self.size == 0: return False",
            "        a, b, i = self._position(x)",
            "        if i == len(a) or a[i] != x: return False",
            "        self._pop(a, b, i)",
            "        return True",
            "    ",
            "    def lt(self, x: T) -> Optional[T]:",
            "        \"\"\"Find the largest element < x, or None if it doesn't exist.\"\"\"",
            "        for a in reversed(self.a):",
            "            if a[0] < x:",
            "                return a[bisect_left(a, x) - 1]",
            "",
            "    def le(self, x: T) -> Optional[T]:",
            "        \"\"\"Find the largest element <= x, or None if it doesn't exist.\"\"\"",
            "        for a in reversed(self.a):",
            "            if a[0] <= x:",
            "                return a[bisect_right(a, x) - 1]",
            "",
            "    def gt(self, x: T) -> Optional[T]:",
            "        \"\"\"Find the smallest element > x, or None if it doesn't exist.\"\"\"",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return a[bisect_right(a, x)]",
            "",
            "    def ge(self, x: T) -> Optional[T]:",
            "        \"\"\"Find the smallest element >= x, or None if it doesn't exist.\"\"\"",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return a[bisect_left(a, x)]",
            "    ",
            "    def __getitem__(self, i: int) -> T:",
            "        \"\"\"Return the i-th element.\"\"\"",
            "        if i < 0:",
            "            for a in reversed(self.a):",
            "                i += len(a)",
            "                if i >= 0: return a[i]",
            "        else:",
            "            for a in self.a:",
            "                if i < len(a): return a[i]",
            "                i -= len(a)",
            "        raise IndexError",
            "    ",
            "    def pop(self, i: int = -1) -> T:",
            "        \"\"\"Pop and return the i-th element.\"\"\"",
            "        if i < 0:",
            "            for b, a in enumerate(reversed(self.a)):",
            "                i += len(a)",
            "                if i >= 0: return self._pop(a, ~b, i)",
            "        else:",
            "            for b, a in enumerate(self.a):",
            "                if i < len(a): return self._pop(a, b, i)",
            "                i -= len(a)",
            "        raise IndexError",
            "    ",
            "    def index(self, x: T) -> int:",
            "        \"\"\"Count the number of elements < x.\"\"\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] >= x:",
            "                return ans + bisect_left(a, x)",
            "            ans += len(a)",
            "        return ans",
            "",
            "    def index_right(self, x: T) -> int:",
            "        \"\"\"Count the number of elements <= x.\"\"\"",
            "        ans = 0",
            "        for a in self.a:",
            "            if a[-1] > x:",
            "                return ans + bisect_right(a, x)",
            "            ans += len(a)",
            "        return ans",
            "$0"
        ],
        "description": "SortedSet class implementation"
    }
}